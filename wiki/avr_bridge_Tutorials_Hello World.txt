## For instruction on writing tutorials
## http://www.ros.org/wiki/WritingTutorials
####################################
##FILL ME IN
####################################
## for a custom note with links:
## note =
## for the canned note of "This tutorial assumes that you have completed the previous tutorials:" just add the links
## note.0=
## descriptive title for the tutorial
## title =Hello World
## multi-line description to be displayed in search
## description = The avr_bridge hello world using an arduino
## the next tutorial description (optional)
## next =
## links to next tutorial (optional)
## next.0.link=
## next.1.link=
## what level user is this tutorial for
## level=BeginnerCategory
## keywords =arduino,  avr
####################################
<<IncludeCSTemplate(TutorialCSHeaderTemplate)>>

<<TableOfContents(4)>>

## AUTOGENERATED DO NOT DELETE
## TutorialCategory
## FILL IN THE STACK TUTORIAL CATEGORY HERE
avr_bridge allows avr microcontrollers to function as full fledged ros components.  For a full introduction to the parts of avr_bridge, see its pkg description.  In this tutorial, we will be doing a hello world program with an Arduino Uno.

First, download the [[http://www.ros.org/wiki/avr_bridge/Tutorials/Hello%20World?action=AttachFile&do=get&target=avrBridgeAVR_example.tar.gz|example avr project here]].  This is an eclipse project set up to compile and program your Arduino.  If you have not done so already, make sure to set up [[http://www.arduino.cc/playground/Code/Eclipse|your eclipse environment for using an Arduino]].

In this tutorial, we will be making a hello world by having the Arduino recieve a message on the the topic "call" and and it will respond "You have sent: " the message data on the topic "response".

== Configuration File ==
The first thing to make when using avr_bridge is the yaml configuration file.  In the example project, this file is called callResponse.yaml.

{{{
port: /dev/ttyUSB0
name: callResponse
publish: #list of published topics
 response: #topic name
  type: std_msgs/String  #msg type
subscribe:
 call:
  type: std_msgs/String
}}}
This configuration specifies the arduino's usb-serial port (/dev/ttyUSB0), the program's name, and the board's subscriptions and publications.  In this case, we are publishing one topic, "response", of type String from the std_msgs pkg.  Similarly, we are subscribing to the topic "call" which is of type std_msgs/String.  We have also named the board callResponse.  You must always name the board.  By naming the board, you can use avr_bridge getID.py to query the board's name and set up a udev rule based on the board's name.

The avr_bridge system works with all ROS messages, but it does not handle all ros primitives correctly.  AVR processors have no float64.  As a result, message fields which are float64 are not serialized, or deserialized correctly on the avr.  Do not use them.

== Generating the Avr Code ==
Inside the avrBridgeAvr_example folder, execute:

{{{
rosrun avr_bridge gen_avr.py callResponse.yaml .
}}}
This command will a generate a folder called avrRos which contains all of the avr  ros files needed to use avr_bridge in your project.  The command automatically generates the c++ implementation for the ros msgs along with the standard communication stack implementation.

== The AVR project ==
Now, import this project into eclipse a look at the included source.  There is a folder, Arduino, with the standard Arduino library headers. This folder, in combination with the pre-compiled library libArduinoDcore.a, will allow us to compile a program for the Arduino uno (or compatible board).  Additionally, there is a main.cpp file and a avr_ros_user.cpp file.

=== avrRos_user.cpp ===
The avr_ros_user.cpp file contains the implementation for board specific hooks used to run the avr_bridge communication stack.  Every program needs to define how to write a byte.  In this case, we are using the uart of the arduino to communicate.

{{{#!cplusplus
namespace ros {
    int fputc(char c, FILE *stream) {
        Serial.write(c);
        return 0;
    }
}
}}}
=== main.cpp ===
The main.cpp is is copied below for convenience.

{{{#!cplusplus
#include "WProgram.h" //include the Arduino library
#include <stdio.h>
#include "avr_ros/ros.h" //main avrRos library
#include "avr_ros/String.h" //std_msg/String library

//Define global message objects to use in
//the callback functions and throughout the program
ros::Publisher resp;
std_msgs::String call_msg;
std_msgs::String response_msg;

void toggle()
{ //toggle an led to debug the program
    static char t=0;
    if (!t ) {
        digitalWrite(13, HIGH);   // set the LED on
        t = 1;
    } else {
        digitalWrite(13, LOW);    // set the LED off
        t = 0;
    }
}

void response(Msg *msg){
        toggle();

        //make sure that if you are manipulating the raw string,
        //there is enough space in it
        //to handle all of the data
        sprintf(response_msg.data.getRawString(),
                "You sent : %s", call_msg.data.getRawString());
        node.publish(resp, &response_msg);
}


// Since we are hooking into a standard
// arduino sketch, we must define our program in
// terms of the arduino setup and loop functions.

void setup()
{
    Serial.begin(57600);

    pinMode(13, OUTPUT); //set up the LED
    resp = node.advertise("response");
    node.subscribe("call",response, &call_msg);

    call_msg.data.setMaxLength(30);
    response_msg.data.setMaxLength(60);
}

void loop()
{
    for(;;) {
        int c = Serial.read();
        if (c == EOF)
            break;
        node.spin(c);
    }

    /* Do other work */
    delay(10);
}
}}}
The main program follows the standard Arduino template, but it has a few complexities added because we are using the library outside of the Arduino IDE and using the avrRos library.

First, in order to use the Arduino library, you must include WProgram.h. Defining __cxa_pure_virtual is optional as avr_ros already provides an implimentation. Both of these are normally included by the Arduino IDE.

As with the Arduino IDE, there is no main function, instead we are using the setup() and loop() hooks.

{{{#!cplusplus
void setup()
{
    Serial.begin(57600);

    pinMode(13, OUTPUT); //set up the LED
    resp = node.advertise("response");
    node.subscribe("call",response, &call_msg);

    call_msg.data.setMaxLength(30);
    response_msg.data.setMaxLength(60);
}

void loop()
{
    for(;;) {
        int c = Serial.read();
        if (c == EOF)
            break;
        node.spin(c);
    }

    /* Do other work */
    delay(10);
}

}}}
Inside the setup, we can see an important feature of the avrRos system.  avrRos declares a global Ros object called "node" which is automatically initialized.  This node object uses the functions defined in avr_ros_user.cpp to communicate with a full fledged computer running ros.

In the avrRos system, the ros publishers are created by calling void node.advertise(char const *topicName). This returns a publisher object that is then used in publishing.  To publish, call :  node.publisher(Publisher pub, Msg *msg_object).

Next, to subscribe to a topic, node.subscribe(char const *topicName, RosCb *cb_function, Msg *msg).  In this example, we subscribe to the "response" topic register the response callback, and use std_msg::String response_msg as the msg object.  This is slightly different from the standard ROS semantics.  For avrRos,  our call back function must be of type RosCb:

{{{#!cplusplus
typedef void (RosCb)(Msg const *msg);
}}}
Additionally, for every subscription, you must register a Msg object of the appropriate type.  This msg object is used to deserialize and store raw binary data sent by the PC.  This interface was chosen in order to handle large ROS messages on the memory limited avr processors.  This way, there can be one global msg object that holds the communication results rather than the processor dynamically generating a new msg object for every transmission.  These msg objects should by exist for the entire life of the program.

In the last portion of setup(), the maximum lengths of call_msg and response_msg are set. These maximum lengths are used to allocate memory for the msg's variable length string.  Every variable length message field must be initialized with a maximum length.  Again, this implementation is a compromise with the limited memory of the avr processor.

Next, in loop, node.spin must be called every iteration.  As in the rest of ROS, node.spin handles the subscription callbacks and other communication work.  Typically, you have node.spin at the head of your loop and the rest of your loop handles the work of the program.

== Running Hello World ==
First, compile the example and program your arduino.

In a new terminal run :

{{{
roscore
}}}
In another terminal, move into the example project directory and start up the bridge node

{{{
rosrun avr_bridge bridge_node.py callResponse.yaml
}}}
Finally, we are going to communicate with the Arduino.  First open a terminal and run

{{{
rostopic echo response
}}}
Finally, run in a new terminal

{{{
rostopic pub call std_msg/String -r1 -- "Hello World"
}}}
The Arduino is receiving hello world and responding on the response topic.  You should see:

{{{
data: You sent : Hello World
}}}
