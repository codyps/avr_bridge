<<PackageHeader(avr_bridge)>> <<TOC(4)>>

## AUTOGENERATED DON'T DELETE
## CategoryPackage
avr_bridge is meant to simplify the use of an Arduino and avr processors in a
ROS based robot by providing a partial ROS implementation in avr c++.    In
hobbyist robotics, these microcontrollers are often used to read sensors and
perform low level motor control.  Every time a robot needs to interface with an
AVR board, a new communication system is written.  Typically they all use a
usb-to-serial converter and either a custom binary or text based protocol.  AVR
bridge  replaces these custom protocols with an automatically generated ROS
communication stack that allows the AVR processors to directly publish or
subscribe to ROS  topics.

== Basic Structure ==

A configuration file specifies the used messages, which is used by `gen_avr`
to generate C++ message serializers. These autogenerated portions as well
as some static source files are copyed into a subdirectory called `avr_ros`
within the folded specified to `gen_avr`.

With properly written additional source code which utilizes the files
within `avr_ros`, the data protocol is parsable by the ros node
`avr_bridge`, which then publishes and subscribes to data the avr
sends/requests via the data link (usually serial).

== Configuration file ==

Every avr_bridge program needs a yaml configuration file which specifies the
port name, the subscriptions, and the publications that each avr handles.  This
is an example configuration file:

{{{#!yaml
port: /dev/ttyUSB0
name: callResponse
publish: #list of published topics
 response: #topic name
  type: std_msgs/String  #msg type
subscribe: #list of subscriptions
 call:
  type: std_msgs/String
}}}

== gen_avr.py : avr_ros source generator ==

The gen_avr.py script is an avr c++ msg generator.  To run gen_avr, perform

{{{
rosrun avr_bridge gen_avr.py <config file> <avr src path>
}}}
This command will generate an avr_ros folder to be included in your avr
project.  This folder has the base msg objects and the avr C++

== API ==

`gen_avr.py` will create a directory called `avr_ros` within the specified
path. This directory contains several autogenerated C++ files whose purpose is
to handle serialization and deserialization of messages.

In the `avr_ros` directory a file called "ros.h" exists which contains an
instance of {{{ros::NodeHandle}}} (note that this is not the same as the
{{{ros::NodeHandle}}} defined in the roscpp api) with the name `node`. All
interaction with avr_ros is done via `node`.

In the user's code, 2 functions must be defined which allow byte-wise
communication by avr_ros.  `void ros::byte_put(uint8_t c)` should send a byte
to the controlling device, and `int ros::byte_get(void)` must return a
byte which was sent from the controlling device. When no data is available,
`byte_get` should return `EOF`. It is recommended that at least the
`byte_put` function be buffered as output is not buffered internally.
`byte_get` may be left unbuffered as input is presently buffered
internally.

The following is an example of this for the Arduino environment.

{{{#!cplusplus
namespace ros {
    void byte_put(char c) {
        Serial.write(c);
    }

    int16_t byte_get(void) {
        return Serial.read()
    }
}
}}}

=== Subscriptions ===

For every subscription, a callback function and callback message must be
registered using ros.subscribe:

{{{#!cplusplus
void ros::NodeHandle::subscribe(char const *name, RosCb *func, Msg *msg);

typedef void (ros::RosCb)(Msg const *msg);
}}}

thus, an example usage is

{{{#!cplusplus
roslib::Header head;
/* head_cb is defined elsewhere */
node.subscribe("test_header", head_cb, &head);
}}}

Note that the callback function may not be a member due to our lack of boost.

The message object is used for both deserialization and storage of the
deserialized data.

==== Handling variable data size in messages ====

Internally, avr_ros avoids all uses of malloc. Because of this, any
variable size things (strings or variable sized arrays, also known as
vectors) need to be supplied with a memory region and it's length before
they can be utilized. The method `.set_mem(void *buf, size_t buf_len)`
which is defined on ros::string and ros::static_vector is used to supply
the object with a memory region of a size the user has deemed appropriate.
Users (on the avr side of things) should be careful to access these items
only up to the `buf_len`, as a matter of efficiency, certain range checks
are not performed. If the avr receives a variable length field in a message
larger than the supplied buffer, the data and length are truncated to the
buffer size.

{{{#!cplusplus
std_msgs::String str;
uint8_t buf[16];
str.set_mem(buf, sizeof(buf));
}}}

Be careful not to size the buffers too large, AVR's have very limited ram
sizes.

=== Publishing Messages ===

{{{#!cplusplus
Header head_pub;
ros::Publisher pub = node.advertise("test_pub");
node.publish(pub, &head_pub);
}}}

`Publisher ros::NodeHandler::advertise(char const *topic_name)` returns a
unique identifier for the given topic. Data may be sent to the controlling
device by calling `void ros::NodeHandler::publish(Publisher pub, Msg *msg)`.

Note that `Publisher` is presently a `uint8_t`.

See the callResponse tutorial for a complete example.

== bridge_node.py ==

 . bridge_node.py is the default method for using AVR processors as first class
 ROS components.  The bridge node reads in the configuration file and
 automatically publishes data sent from your avr processor. It uses pyserial to
 talk to the avr processor.  It expects to have the configuration yaml file as
 its first argument.  It automatically opens the avr port starts talking to the
 avr, and subscribes and publishes the messages.  To use run:

{{{
rosrun avr_bridge bridge_node.py <config file>
}}}

== System Caveats ==
float64 UNSUPPORTED: avr-libc makes both doubles and floats 32 bit, thus
serialization and deserialization of float64 fields will not produce
intelligible results. In the future, a compatibility converter between 32bit
and 64bit floats may be utilized internally.

For a more in depth explanation of c++ programming with embedded processor
constraints, see   http://nrqm.pbworks.com/Embedded+Object-Oriented+Programming
