#!/usr/bin/env python
# vim: sw=8 ts=8 sts=8 noet 
"""
AVR code generator for ROS topics.  This utilities are used to generate
the avr source code to communicate with the ros avr bridge.  

by Adam Stambler of Rutger University.

This software was written with support of a research grant (R01ES014717)
 from the National Institute of Environmental Health Sciences.  

# Software License Agreement (BSD License)
#
# Copyright (c) 2011, Adam Stambler
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Adam Stambler, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#


"""
import roslib; roslib.load_manifest('avr_bridge')

import sys
import shutil
import os
import traceback

import roslib.msgs 
import roslib.packages 


import roslib.genpy 
import yaml
import StringIO

from c_writer import SimpleStateC

primatives = {
	'bool'  :   ('bool', 1) ,
	'byte'  :   ('uint8_t', 1),
	'int8'  :   ('uint8_t', 1),
	'int16' :   ('int16_t', 2),
	'uint16':   ('uint16_t', 2),
	'int32':    ('int32_t', 4),
	'uint32':   ('uint32_t', 4),
	'int64':    ('int64_t',8),
	'uint64':   ('uint64_t',8),
	'float32':  ('float', 4 ),
	'float64':  ('double', 8),
	'time':     ('int64_t',8),
	'duration': ('int64_t',8),
	'string' :  ('ROS::string', 0)
}

def extract_ros_type(field):
	"""	extract the basic type
		from the msg_spec field
		without the array symbols
		and with the pkg separted
	"""
	try:
		incPkg, incName = field.type.split('/')
	except:
		incPkg = None
		incName = field.type
	if field.is_array:
		incName = incName[:incName.find('[')]
	return incPkg, incName
	
def serialize_primative(f, buffer_addr, field):
	"""	Generate c code to serialize rostype of fieldname at the buffer 
	"""
	fpkg, ftype = extract_ros_type(field)
	ctype, clen = primatives[ftype]
	
	
	if (field.is_array or field.type == 'string'):
		f.write('offset += this->%s.serialize(%s + offset);\n'%(field.name, buffer_addr))
	else:
		f.write("*( (%s *) (%s + offset))=  this->%s; \n"%(ctype, buffer_addr, field.name) )
		f.write('offset += %d;\n'%(clen)) 
		
def deserialize_primative(f, buffer_addr, field):
	"""	Generate c code to deserialize a rosmsg field of type ctype from 
		specified buffer.
	"""
	fpkg, ftype = extract_ros_type(field)
	ctype, clen = primatives[ftype]

	if (field.is_array or field.type == 'string'):
		f.write('offset+= this->%s.deserialize(%s+offset);\n'%(field.name, buffer_addr))
	else:
		f.write( "this->%s = *( (%s *) (%s + offset) );\n"%(field.name, ctype, buffer_addr) )
		f.write('offset += %d;\n'%(clen))
				

def write_header_file(f, msg_name, pkg, msg_spec):
	"""f is a file like object to which the header file is being outputed
	msg_name is the name of the msg
	pkg is the msg's pkg
	includes is a list of file names that should be included
	filds is a list of touples of field type, name, array, array_length
	"""
	#write comments
	f.line('/* {0}.h'.format(msg_name))
	f.line(' * MSG file auto generated by "Rutgers avr_bridge"')
	f.line(' */')
	
	#write header guards
	guard =  msg_name+'_H'
	guard = guard.upper()
	f.macro_line('ifndef {0}'.format(guard))
	f.macro_line('define {0}'.format(guard))

	f.macro_line('include "Msg.h"')
	f.macro_line('include "vector.h"')
	f.macro_line('include "ros_string.h"')

	#write includes
	for field in msg_spec.parsed_fields():
		if not field.is_builtin:
			incPkg, incName = extract_ros_type(field)
			f.macro_line('include "{0}.h"'.format(incName))
	
	#open namespace

	f.line('namespace {0} {{'.format(pkg))
	f.indent()

	f.line('class {0} : public Msg {{'.format(msg_name))
	f.line('public:')
	f.indent()

	f.line('{0}();'.format(msg_name))
	f.line('{0}(uint8_t *data);'.format(msg_name))
	f.line('~{0}();'.format(msg_name)

	f.line('uint16_t bytes();')
	f.line('uint16_t serialize(uint8_t *out_buffer);')
	f.line('uint16_t deserialize(uint8_t *data);')
	
	#write msg fields
	for field in msg_spec.parsed_fields():
		fpkg, ftype = extract_ros_type(field)
		if fpkg != None:
			ftype = fpkg +"::"+ftype
		if ftype == 'Header':
			ftype = "roslib::"+ftype
		if field.is_builtin:
			ftype, clen = primatives[ftype]
		if field.is_array:
			if field.array_len:
				f.line('ROS::vector<{0}> {1}; // fixed at length {2}'.format(ftype, field.name, field.array_len)
			else :
				f.line('ROS::vector<{0}> {1};'.format(ftype, field.name))
		else:
			f.line('{0} {1};'.format(ftype, field.name))
	
	f.dedent()
	f.line('}}; /* class {0} */'.format(msg_name))

	#close namespace
	f.dedent()
	f.line('}} /* namespace {0} */'.format(pkg))
	#closing header guards
	f.macro_line('endif /* {0} */'.format(guard))

def serialize_msg(f, msg_spec):
	f.write('\nint offset=0;\n')
	
	for field in msg_spec.parsed_fields():
		if (field.is_builtin):
			serialize_primative(f, 'data', field)
		else:
			f.write('offset += this->%s.serialize(%s + offset);\n'%(field.name, 'data'))
			
	f.write('\n return offset;\n')

def deserialize_msg(f, msg_spec):
	f.write('\nint offset=0;\n')
	
	for field in msg_spec.parsed_fields():
		if (field.is_builtin):
			deserialize_primative(f, 'data', field)
		else:
			f.write('offset += this->%s.deserialize(%s + offset);\n'%(field.name, 'data'))
			
	f.write('\n return offset;\n')



def msg_size(f, msg_spec):
	"""
This function writes out the bytes() member function for a msg.  
It iterates through the msg fields and extracts either their size if 
they are a primative type, or calls the bytes of that msg.

	@param f :  output file object
	@param msg_spec : the msg_spec of the msg
	"""
	f.write('\n int msgSize=0;\n')
	
	for field in msg_spec.parsed_fields():
		if (field.is_builtin and not (field.type == 'string') ):
			fpkg, ftype = extract_ros_type(field)
			ctype, clen = primatives[ftype]
			f.write('msgSize += sizeof(%s);\n'%(ctype))
		else:
			f.write('msgSize += %s.bytes();\n'%field.name)
	
	f.write('return msgSize;\n')
	

def write_cpp(f, msg_name, pkg, msg_spec):
	"""
		Generates the msg cpp implementation file
		@param f : output file object
		@param msg_name : name of msg type
		@param pkg : pkg that the message is found in
		@param msg_spec : msg_spec object of the msg
	"""


	f.macro_line('include "{0}.h"'.format(msg_name))
	f.macro_line('include <stdio.h>')
	
	f.macro_line('using namespace {0};'.format(pkg))
	
	def writeFunct(rtype, msg, funct, args, implementation):
		if rtype != '':
			f.line('{0} {1}::{2}({3})'.format(rtype,msg,funct,args))
		else:
			f.line('{0}::{2}({3})'.format(msg, funct, args))
		f.line('{')
		f.indent()
		implementation(f)
		f.dedent()
		f.line('}')
	
	#write constructor
	f.line('{0}::{0}()'.format(msg_name))
	#set fixed length arrays
	constructor_init=''
	for field in msg_spec.parsed_fields():
		if field.is_array:
			if field.array_len:
				constructor_init +='%s(%d),' %(field.name, field.array_len)
	if (len(constructor_init) > 3):
		f.line( ':' + constructor_init[:-1])
	f.line('{}')
	

	writeFunct('', msg_name, '~'+msg_name, '', lambda f: 0)

	writeFunct('', msg_name, msg_name,'uint8_t *data', lambda f: f.line('this->deserialize(data);'))
	
	writeFunct('uint16_t ', msg_name, 'serialize', 'uint8_t *data', lambda f: serialize_msg(f, msg_spec))
	writeFunct('uint16_t ', msg_name, 'deserialize', 'uint8_t *data', lambda f: deserialize_msg(f,msg_spec))
	writeFunct('uint16_t ', msg_name, 'bytes', '', lambda f: msg_size(f, msg_spec))

class CGenerator():
	"""
	Class responsible for generating the c++ files from the yaml 
	configuration file.
	"""
	def __init__(self):
		self.types = [] #contains list of distinct types 
						#each type will generate a .h and .cpp file
		self.msg_specs = {} #dict containing the msg spec for each type
		
		self.topicIds = {}
		self._topicIds = 0
		
		self.config = None
		
	def parseConfig(self, configFile):
		"""
			Takes a file like object of the yaml configuration 
		"""
		
		self.config = yaml.load(configFile)
		
		#services get their topic id first
		if self.config.has_key('service'):
			for topic in self.config['service']:
				#import that msg's python module
				msg_type = self.config['service'][topic]['type']

			#TODO IMPLEMENT SERVICES

				self.topicIds[topic] = self._topicIds
				self._topicIds +=1
											
		
		#subscribes must get their topic id first
		if self.config.has_key('subscribe'):
			for topic in self.config['subscribe']:
				#import that msg's python module
				msg_type = self.config['subscribe'][topic]['type']
								
				self.addMsg(topic, msg_type)
				
				self.topicIds[topic] = self._topicIds
				self._topicIds +=1

		
		if self.config.has_key('publish'):
			for topic in self.config['publish']:
				#import that msg's python module
				msg_type = self.config['publish'][topic]['type']
	
				self.addMsg(topic, msg_type)
				
				self.topicIds[topic] = self._topicIds
				self._topicIds +=1
		
	def addMsg(self, pkg, name):
		"""
		@param pkg  The package that the msg is found in
		@param msg  The name of the msg 
		"""
				
		msg_name, msg_spec = roslib.msgs.load_by_type(name, pkg)
		if not (msg_name in self.types):
			self.types.append(msg_name)
			self.msg_specs[msg_name] = msg_spec
			
			#now that we are done adding the base msg type, we need to
			#recursively add all the types defined within it
			for msgType in msg_spec.types:
				if msgType[-1] == ']': #strip away array markers
					msgType = msgType[0:msgType.find('[')]

				if msgType == 'Header':
					self.addMsg('roslib', 'Header')
				elif primatives.has_key(msgType) or msgType== 'string':
					pass
				else:
					print "The msg type is ", msgType
					tpkg, tmsg = msgType.split('/')
					self.addMsg(tpkg, tmsg)


	def generateRos(self, folderPath):
		""" 
	This function generates to ros_generated.cpp file.
	This file contains the getTopicTag implementation along with
	the instantiation of the ros object.
		"""
		fo = open(folderPath+'/ros_generated.cpp', 'w');
		
		f = SimpleStateC(f)

		f.line('/* This file was autogenerated as a part of the avr_bridge pkg'
		f.line(' * avr_bridge was written by Adam Stambler and Phillip Quiza of')
		f.line(' * Rutgers University.')
		f.line(' */')

		f.macro_line('include "Ros.h"')

		f.line('char Ros::getTopicTag(char *topic) {')
		f.indent()

		for topic_name, topic_id in self.topicIds.iteritems():
			f.line('if (!strcmp(topic, "{0}"))'.format(topic_name))
			f.indent()
			f.line('return {0};'.format(topic_id)
			f.dedent()


		f.line('return 0')
		f.dedent()

		f.line('}')


		f.line('Ros ros({0}, {1});'.format(self.config['name'], len(self.topicIds)))
		f.close()
		
		
	def generateMsgFile(self, folderPath, msg):
		pkg, msg_name = msg.split('/')
		
		header_file = open(folderPath+'/'+msg_name+'.h', 'w')
		f = SimpleStateC(header_file)
		write_header_file(f, msg_name, pkg, self.msg_specs[msg])
		header_file.close()
	
		cpp_file = open(folderPath+'/'+msg_name+'.cpp','w')
		f = SimpleStateC(cpp_file)
		write_cpp(f, msg_name, pkg, self.msg_specs[msg])
		
	def generate(self, folderPath):
		""" generate the ros implementation for the avr code
		"""
		genPath = roslib.packages.find_resource('avr_bridge' ,'gen_avr.py')[0]
		avrRosPath =  genPath[:-len('gen_avr.py')]+ 'avrRos'
		
		
		try:
			shutil.copytree(avrRosPath, folderPath+'/avrRos')
		except Exception as e:
			print "avrRos already exists in ", folderPath
			print "The new files are overwriting the old files"
		
		for t in self.types:
			self.generateMsgFile(folderPath+'/avrRos', t)
		
		self.generateRos(folderPath+'/avrRos')
		
	
	
def test():
	roslib.msgs.set_verbose(False)
    
	typeList = []
	
	msg_name = 'Odometry'
	pkg_name = 'nav_msgs'
	msg_path = roslib.msgs.msg_file(pkg_name, msg_name)
	msg_name, msg_spec = roslib.msgs.load_from_file(msg_path)
	
	gen = CGenerator()
	gen.addMsg(pkg_name, msg_name)
	 
